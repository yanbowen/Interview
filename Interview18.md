## UML定义了以下5类、10种模型图。

* 第一类是**用例图** ，用例图从用户角度描述系统的功能，并指出各功能的操作者。

* 第二类是**静态图**，包括**类图，对象图和包图** 。其中类图用于定义系统中的类，包括描述类之间的联系（如关联、依赖、聚合等）以及类的内部结构，即类的属性和操作。因此类图描述系统中类的静态结构，它描述的是一种静态关系，在系统的整个生命周期都是有效的。对象图所使用的表示符号与类图几乎相同，它们的不同点在于对象图只显示类的对象实例，而不是实际的类。 一个对象图是类图的一个实例。由于对象有生命周期，所以对象图只在系统的某段时间有效。包图由包或类组成，主要表示包与包或包与类之间的关系，包图用于描述系统的分层结构。

* 第三类是**行为图** ，描述系统的动态模型和对象间的交互关系。一种是**状态图** ，它描述一类对象可能的状态以及事件发生时状态迁移的条件。通常状态图是对类图的补充，我们并不需要对所有的类绘制状态图，而只要为那些有多个状态，并且其行为受外界影响而会发生改变的类绘制状态图。另一种称为**活动图**，它描述为满足用例要求所要进行的活动及活动见的约束关系，使用活动图可以方便地表示并进行活动。

* 第四类是**交互图** ，它描述对象间的交互关系。一种称之为**顺序图** ，用以描述对象间的动态合作关系，它强调对象之间消息发送的顺序，同时也显示对象之间的交互过程。另一种是**合作图** ，它着重描述对象间的协作关系。合作图和顺序图类似，显示对象间的动态合作关系。除了显示信息交换外，合作图还显示对象以及对象之间的关系。如果强调时间和顺序，应当使用顺序图；如果强调通信关系，则可以选择合作图，这两种图合称为交互图。

* 第五类是**实现图**，包括**构件图和配置图**。构件图描述代码部件的物理结构和各部件之间的依赖关系。一个部件肯能是一个资源代码部件、一个二进制部件或一个可执行部件，它包含逻辑类和实现类的有关信息。构件图有助于分析和理解部件之间的相互影响程度。配置图定义系统中的软硬件物理体系结构，它可以显示实际的计算机和设备（用节点表示）以及它们之间的连接关系，也可以显示连接的类型和部件或部件之间的依赖性。在节点内部，放置可执行的部件和对象，以显示节点和可执行单元之间的对应关系。   

   
## 什么是Just In Time编译器?
>JIT并不是JVM的必须部分，JVM规范并没有规定JIT必须存在，更没有限定和指导JIT。但是，JIT性能的好坏、代码优化程度的高低却是衡量一款JVM是否优秀的最关键指标之一，也是虚拟机中最核心且最能体现虚拟机技术水平的部分。  
>
### Hot Spot 编译
当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：   

首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。   

当 然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代 码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。   

第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。   

我 们将在后面讲解这些优化策略，这里，先举一个简单的例子：我们知道 equals() 这个方法存在于每一个 Java Object 中（因为是从 Object class 继承而来）而且经常被覆写。当解释器遇到 b = obj1.equals(obj2) 这样一句代码，它则会查询 obj1 的类型从而得知到底运行哪一个 equals() 方法。而这个动态查询的过程从某种程度上说是很耗时的。   

在主流商用JVM（HotSpot、J9）中，Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In Time Compiler，JIT）   

JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器    
    
   
---   
   
## ArrayList的底层实现原理   
   
一、 ArrayList概述：  

ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。   

ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。   
   
ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。   

每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。    
   
注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。   
    
### 关于ArrayList和Vector区别如下：

* ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。
* Vector提供indexOf(obj, start)接口，ArrayList没有。
* Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。    

  
### 总结:

关于ArrayList的源码，给出几点比较重要的总结：

* 1、注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。

* 2、注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。

* 3、ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。

首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：    
   
	public static <T> T[] copyOf(T[] original, int newLength) {  
	    return (T[]) copyOf(original, newLength, original.getClass());  
	}    
   
  
很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：   
   
	public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {  
	    T[] copy = ((Object)newType == (Object)Object[].class)  
	        ? (T[]) new Object[newLength]  
	        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  
	    System.arraycopy(original, 0, copy, 0,  
	                     Math.min(original.length, newLength));  
	    return copy;  
	}    
   
这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。

下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。    
   
* 4、ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。

* 5、在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。    

   
## LinkedList实现原理要点概括   
   
* LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。
* 底层的数据结构是基于双向链表的，该数据结构我们称为节点
* 双向链表节点对应的类Node的实例，Node中包含成员变量：prev，next，item。其中，prev是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。
* 它的查找是分两半查找，先判断index是在链表的哪一半，然后再去对应区域查找，这样最多只要遍历链表的一半节点即可找到   

   
## HashMap实现原理要点概括   
   
* HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。
* 底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。
* HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。
* HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能
* 采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常   

## R-B Tree简介   
  
R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。
  
红黑树的特性:   

	（1）每个节点或者是黑色，或者是红色。
	（2）根节点是黑色。
	（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
	（4）如果一个节点是红色的，则它的子节点必须是黑色的。
	（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。   
   
   
红黑树的时间复杂度为: O(lgn)   
   
定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).